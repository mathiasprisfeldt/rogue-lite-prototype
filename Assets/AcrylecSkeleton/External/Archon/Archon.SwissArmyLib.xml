<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Archon.SwissArmyLib</name>
    </assembly>
    <members>
        <member name="T:Archon.SwissArmyLib.Automata.IPdaState`1">
            <summary>
            Represents a state to be used in a <see cref="T:Archon.SwissArmyLib.Automata.PushdownAutomaton`1"/>.
            </summary>
            <typeparam name="T">The type of the context.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.IPdaState`1.Pause">
            <summary>
            Called when a state is pushed ontop of this state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.IPdaState`1.Resume">
            <summary>
            Called when the state above us is popped.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Automata.IState`2">
            <summary>
            Represents a state to be used in a state machine.
            
            You might be looking for <see cref="T:Archon.SwissArmyLib.Automata.IFsmState`1"/> or <see cref="T:Archon.SwissArmyLib.Automata.IPdaState`1"/>.
            </summary>
            <typeparam name="TMachine">The type of the machine.</typeparam>
            <typeparam name="TContext">The type of the context.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.IState`2.Machine">
            <summary>
            The state machine this state belongs to.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.IState`2.Context">
            <summary>
            The context for this state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.IState`2.Begin">
            <summary>
            Called when the state is entered.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.IState`2.Reason">
            <summary>
            Called every frame just before <see cref="M:Archon.SwissArmyLib.Automata.IState`2.Act(System.Single)"/>. 
            Use this to check whether you should change state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.IState`2.Act(System.Single)">
            <summary>
            Called every frame after <see cref="M:Archon.SwissArmyLib.Automata.IState`2.Reason"/>, if the state hasn't been changed.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.IState`2.End">
            <summary>
            Called when the state is exited.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Automata.PdaState`1">
            <summary>
            A simple abstract class that implements <see cref="T:Archon.SwissArmyLib.Automata.IPdaState`1"/> and can be used in a <see cref="T:Archon.SwissArmyLib.Automata.PushdownAutomaton`1"/>
            
            You're not required to use this, but it's easier.
            </summary>
            <typeparam name="T">The type of the context.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PdaState`1.Pause">
            <summary>
            Called when a state is pushed ontop of this state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PdaState`1.Resume">
            <summary>
            Called when the state above us is popped.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Automata.PushdownAutomaton`1">
             <summary>
             A simple <see href="https://en.wikipedia.org/wiki/Pushdown_automaton">Pushdown Automaton</see> with states as objects.
             
             If your state classes have an empty constructor, the state machine can register the states automatically when needed (using <see cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PushStateAuto``1"/> and <see cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.ChangeStateAuto``1"/>).
             If not you should register the states yourself using <see cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.RegisterStateType``1"/> or <see cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.RegisterStateType(System.Type,System.Func{Archon.SwissArmyLib.Automata.IPdaState{`0}})"/> and use the regular.
             
             The machine will automatically pool the states so you don't have to worry about it.
            
             Whether or popping the last state is valid is up to your design.
             
             <seealso cref="T:Archon.SwissArmyLib.Automata.IPdaState`1"/>
             <seealso cref="T:Archon.SwissArmyLib.Automata.PdaState`1"/>
             </summary>
             <typeparam name="T">The type of the context.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.Context">
            <summary>
            A shared context which all states have access to.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.CurrentState">
            <summary>
            The active state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.#ctor(`0)">
            <summary>
            Creates a new PushdownAutomaton.
            
            You should use <see cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.RegisterStateType(System.Type,System.Func{Archon.SwissArmyLib.Automata.IPdaState{`0}})"/> to register which state types that can be used with the machine.
            </summary>
            <param name="context">Data shared among states</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.Update(System.Single)">
            <summary>
            Call this every time the machine should update. Eg. every frame.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.ChangeState``1">
            <summary>
            Replaces the active state with another state, without notifying the underlying state.
            </summary>
            <typeparam name="TState">The type of the state to change to.</typeparam>
            <returns>The state instance that was changed to.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.ChangeStateAuto``1">
            <summary>
            Replaces the active state with another state, without notifying the underlying state.
            
            If the state is not registered, it will automatically be and its empty constructor will be used to create the instances.
            
            <seealso cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.ChangeState``1"/>
            </summary>
            <typeparam name="TState">The type of the state to change to.</typeparam>
            <returns>The state instance that was changed to.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PopState">
            <summary>
            Pops the current state and resumes the underlying state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PopStateSilently">
            <summary>
            Pops the current state without notifying the underlying state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PopAll(System.Boolean)">
            <summary>
            Pops all states in the stack.
            </summary>
            <param name="excludingRoot">Whether to keep the bottom state.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PushState``1">
            <summary>
            Pushes a state to the top of the stack and pauses the underlying state.
            </summary>
            <typeparam name="TState">The type of the state to change to.</typeparam>
            <returns>The new state.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PushStateSilently``1">
            <summary>
            Pushes a state to the top of the stack without notifying the underlying state.
            </summary>
            <typeparam name="TState">The type of the state to change to.</typeparam>
            <returns>The new state.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PushStateAuto``1">
            <summary>
            Pushes a state to the top of the stack and pauses the underlying state.
            
            If the state is not registered, it will automatically be and its empty constructor will be used to create the instances.
            
            <seealso cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PushState``1"/>
            </summary>
            <typeparam name="TState">The type of the state to change to.</typeparam>
            <returns>The new state.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PushStateSilentlyAuto``1">
            <summary>
            Pushes a state to the top of the stack without notifying the underlying state.
            
            If the state is not registered, it will automatically be and its empty constructor will be used to create the instances.
            
            <seealso cref="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.PushStateSilently``1"/>
            </summary>
            <typeparam name="TState">The type of the state to change to.</typeparam>
            <returns>The new state.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.ObtainState``1">
            <summary>
            Obtains a pooled instance of the given type.
            </summary>
            <typeparam name="TState">The type of the state to obtain.</typeparam>
            <returns>The new or recycled state.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.FreeState(Archon.SwissArmyLib.Automata.IPdaState{`0})">
            <summary>
            Frees a state instance and makes it available for reuse.
            </summary>
            <param name="state">The state to free.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.GetPool(System.Type)">
            <summary>
            Gets a pool for the given state type.
            </summary>
            <param name="stateType">The state type to get the pool for.</param>
            <returns>The pool, or null if not found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.RegisterStateType``1">
            <summary>
            Registers a state type in the machine. 
            
            A pool for the type will be created that will use the empty constructor.
            </summary>
            <typeparam name="TState"></typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.RegisterStateType(System.Type,System.Func{Archon.SwissArmyLib.Automata.IPdaState{`0}})">
            <summary>
            Registers a state type in the machine. 
            
            A pool for the type will be created which uses the given creationMethod to create new instance when needed.
            </summary>
            <param name="type">The state type to register.</param>
            <param name="creationMethod">The factory method to use for creating instances.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.PushdownAutomaton`1.IsRegistered``1">
            <summary>
            Checks whether a state type is registered in the machine.
            </summary>
            <typeparam name="TState">The state type to check for.</typeparam>
            <returns>True if registered, otherwise false.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Automata.IFsmState`1">
            <summary>
            Represents a state to be used in a <see cref="T:Archon.SwissArmyLib.Automata.FiniteStateMachine`1"/>.
            </summary>
            <typeparam name="T">The type of the context.</typeparam>
        </member>
        <member name="T:Archon.SwissArmyLib.Automata.FsmState`1">
            <summary>
            A simple abstract class that implements <see cref="T:Archon.SwissArmyLib.Automata.IFsmState`1"/> and can be used in a <see cref="T:Archon.SwissArmyLib.Automata.FiniteStateMachine`1"/>
            
            You're not required to use this, but it's easier.
            </summary>
            <typeparam name="T">The type of the context.</typeparam>
        </member>
        <member name="T:Archon.SwissArmyLib.Automata.FiniteStateMachine`1">
             <summary>
             A simple <see href="https://en.wikipedia.org/wiki/Finite-state_machine">Finite State Machine</see> with states as objects inspired by Prime31's excellent <see href="https://github.com/prime31/StateKit">StateKit</see>.
            
             If your state classes have an empty constructor, the state machine can create the states automatically when needed (using <see cref="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.ChangeStateAuto``1"/>).
             If not you should create the state instance yourself and register the state in the machine.
            
             Whether or not a null state is valid is up to your design.
             
             <seealso cref="T:Archon.SwissArmyLib.Automata.IFsmState`1"/>
             <seealso cref="T:Archon.SwissArmyLib.Automata.FsmState`1"/>
             </summary>
             <typeparam name="T">The type of the context.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.Context">
            <summary>
            A shared context which all states have access to.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.CurrentState">
            <summary>
            The active state.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.PreviousState">
            <summary>
            The previously active state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.#ctor(`0)">
            <summary>
            Creates a new Finite State Machine.
            
            If you need control over how the states are created, you can register them manually using <see cref="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.RegisterState(Archon.SwissArmyLib.Automata.IFsmState{`0})"/>.
            If not, then you can freely use <see cref="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.ChangeStateAuto``1"/> which will create the states using their default constructor.
            </summary>
            <param name="context">A shared context for the states.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.#ctor(`0,Archon.SwissArmyLib.Automata.IFsmState{`0})">
            <summary>
            Creates a new Finite State Machine and changes the state to <paramref name="startState"/>.
            
            If you need control over how the states are created, you can register them manually using <see cref="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.RegisterState(Archon.SwissArmyLib.Automata.IFsmState{`0})"/>.
            If not, then you can freely use <see cref="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.ChangeStateAuto``1"/> which will create the states using their default constructor.
            </summary>
            <param name="context"></param>
            <param name="startState"></param>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.Update(System.Single)">
            <summary>
            Call this every time the machine should update. Eg. every frame.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.RegisterState(Archon.SwissArmyLib.Automata.IFsmState{`0})">
            <summary>
            Preemptively add a state instance.
            Useful if the state doesn't have an empty constructor and therefore cannot be used with ChangeStateAuto.
            </summary>
            <param name="state">The state to register.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.IsStateRegistered(System.Type)">
            <summary>
            Checks whether a state type is registered.
            </summary>
            <param name="stateType">The state type to check.</param>
            <returns>True if registered, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.IsStateRegistered``1">
            <summary>
            Generic version of <see cref="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.IsStateRegistered(System.Type)"/>.
            Checks whether a state type is registered.
            </summary>
            <typeparam name="TState">The state type to check.</typeparam>
            <returns>Tru if registered, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.ChangeStateAuto``1">
            <summary>
            Changes the active state to the given state type.
            If a state of that type isn't already registered, it will automatically create a new instance using the empty constructor.
            </summary>
            <typeparam name="TState"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.ChangeState``1">
            <summary>
            Changes the active state to the given state type. 
            An instance of that type should already had been registered to use this method.
            </summary>
            <typeparam name="TState"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.FiniteStateMachine`1.ChangeState``1(``0)">
            <summary>
            Changes the active state to a specific state instance.
            This will (if not null) also register the state.
            </summary>
            <typeparam name="TState"></typeparam>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Automata.BaseState`2">
            <summary>
            A simple abstract class that implements <see cref="T:Archon.SwissArmyLib.Automata.IState`2"/>.
            
            You might be looking for <see cref="T:Archon.SwissArmyLib.Automata.FsmState`1"/> or <see cref="T:Archon.SwissArmyLib.Automata.PdaState`1"/>.
            </summary>
            <typeparam name="TMachine">The type of the machine.</typeparam>
            <typeparam name="TContext">The type of the context.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.BaseState`2.Machine">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.BaseState`2.Context">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.Automata.BaseState`2.TimeInState">
            <summary>
            Amount of (active) time spent in this state since it was entered.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.BaseState`2.Begin">
            <summary>
            Called when the state is entered.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.BaseState`2.Reason">
            <summary>
            Called every frame just before <see cref="M:Archon.SwissArmyLib.Automata.BaseState`2.Act(System.Single)"/>. 
            Use this to check whether you should change state.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.BaseState`2.Act(System.Single)">
            <summary>
            Called every frame after <see cref="M:Archon.SwissArmyLib.Automata.BaseState`2.Reason"/>, if the state hasn't been changed.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Automata.BaseState`2.End">
            <summary>
            Called when the state is exited.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Collections.DelayedList`1">
            <summary>
                A list wrapper that delays adding or removing item from the list until <see cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.ProcessPending" /> is called.
            </summary>
            <typeparam name="T">The type of items this list should contain.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.DelayedList`1.Count">
            <summary>
                Gets the amount of items in the list.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.#ctor">
            <summary>
                Creates a new DelayedList which uses <see cref="T:System.Collections.Generic.List`1" />.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
                Creates a new DelayedList that wraps the given list.
            </summary>
            <param name="list">The list to wrap.</param>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.DelayedList`1.BackingList">
            <summary>
                A readonly version of the list containing processed items.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.DelayedList`1.Item(System.Int32)">
            <summary>
                Gets the item at a specific index.
            </summary>
            <param name="index">The index of the item.</param>
            <returns>The item at the specified index.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.GetEnumerator">
            <summary>
                Gets an enumerator for the backing list.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Gets an enumerator for the backing list.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.Add(`0)">
            <summary>
                Adds an item to the list the next time <see cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.ProcessPending" /> is called.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.Remove(`0)">
            <summary>
                Removes an item from the list the next time <see cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.ProcessPending" /> is called.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.Clear">
            <summary>
                Clears all items from the list and all pending additions and removals.
                <remark>
                    <see cref="E:Archon.SwissArmyLib.Collections.DelayedList`1.PreItemAddition" /> and <see cref="E:Archon.SwissArmyLib.Collections.DelayedList`1.PreItemRemoval" /> are not invoked by this method!
                </remark>
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.Contains(`0)">
            <summary>
                Checks whether the backing list currently contains a specific item.
            </summary>
            <param name="item">The item to check for.</param>
            <returns>True if found, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.CopyTo(`0[],System.Int32)">
            <summary>
                Copies the contents of the backing list to the specified array starting at the specified index.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="arrayIndex">The index to start from.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.IndexOf(`0)">
            <summary>
                Gets the index of an item in the list.
            </summary>
            <param name="item">The item to get the index for.</param>
            <returns>The index of the item, or -1 if not found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.RemoveAt(System.Int32)">
            <summary>
                Removes the item found at the specified index the next time <see cref="M:Archon.SwissArmyLib.Collections.DelayedList`1.ProcessPending" /> is called.
            </summary>
            <param name="index"></param>
        </member>
        <member name="E:Archon.SwissArmyLib.Collections.DelayedList`1.PreItemAddition">
            <summary>
                Called just before pending items are actually added to the list.
            </summary>
        </member>
        <member name="E:Archon.SwissArmyLib.Collections.DelayedList`1.PreItemRemoval">
            <summary>
                Called just before pending items are actually removed from the list.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DelayedList`1.ProcessPending">
            <summary>
                Processes all pending additions and removals.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Collections.DictionaryWithDefault`2">
            <summary>
            A <see cref="T:System.Collections.Generic.Dictionary`2"/> but with a default value for missing entries.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.DictionaryWithDefault`2.DefaultValue">
            <summary>
            Default value for missing entries.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.DictionaryWithDefault`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the given key.
            
            If the key isn't in the dictionary, <see cref="P:Archon.SwissArmyLib.Collections.DictionaryWithDefault`2.DefaultValue"/> will be returned.
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DictionaryWithDefault`2.#ctor">
            <summary>
            Creates a new Dictionary with DefaultValue set to TValue's default value.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DictionaryWithDefault`2.#ctor(`1)">
            <summary>
            Creates a new Dictionary using the supplied value as the default for missing entries.
            </summary>
            <param name="defaultValue"></param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.DictionaryWithDefault`2.#ctor(`1,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a new Dictionary using the supplied value as the default for missing entries and a specific comparer.
            </summary>
            <param name="defaultValue"></param>
            <param name="comparer"></param>
        </member>
        <member name="T:Archon.SwissArmyLib.Collections.Grid3D`1">
            <summary>
            A generic three-dimensional grid.
            
            <seealso cref="T:Archon.SwissArmyLib.Collections.Grid2D`1"/>
            </summary>
            <typeparam name="T">The type of content cells can contain.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid3D`1.Width">
            <summary>
            Gets the width (number of columns) of the grid.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid3D`1.Height">
            <summary>
            Gets the height (number of rows) of the grid.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid3D`1.Depth">
            <summary>
            Gets the depth (number of layers) of the grid.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid3D`1.DefaultValue">
            <summary>
            Gets or sets the default values used for clearing or initializing new cells.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid3D`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets or sets the value of the cell located at the specified coordinate.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <returns>The contents of the cell.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new 3D Grid with the specified width, height and depth. 
            Cells will be initialized with their type's default value.
            </summary>
            <param name="width">Number of columns</param>
            <param name="height">Number of rows</param>
            <param name="depth">Number of layers</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.#ctor(System.Int32,System.Int32,System.Int32,`0)">
            <summary>
            Creates a new 3D Grid with the specified width, height and depth. 
            Cells will be initialized with the value of <paramref name="defaultValue"/>.
            </summary>
            <param name="width">Number of columns</param>
            <param name="height">Number of rows</param>
            <param name="depth">Number of layers</param>
            <param name="defaultValue">The value used for initializing new cells.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.Get(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the value of the cell located at the specified coordinate.
            
            <seealso cref="P:Archon.SwissArmyLib.Collections.Grid3D`1.Item(System.Int32,System.Int32,System.Int32)"/>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <returns>The cell contents.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.Set(System.Int32,System.Int32,System.Int32,`0)">
            <summary>
            Sets the value of the cell located at the specified coordinate.
            
            <seealso cref="P:Archon.SwissArmyLib.Collections.Grid3D`1.Item(System.Int32,System.Int32,System.Int32)"/>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <param name="value">The value to set the cell to.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.Clear">
            <summary>
            Clears the grid, setting every cell to <see cref="P:Archon.SwissArmyLib.Collections.Grid3D`1.DefaultValue"/>.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.Clear(`0)">
            <summary>
            Clears the grid, setting every cell to the given value.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.Fill(`0,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Fills everything in the specified cube to the given value.
            </summary>
            <param name="value">The value to fill the cells with.</param>
            <param name="minX">Bottom left front corner's x value.</param>
            <param name="minY">Bottom left front corner's y value.</param>
            <param name="minZ">Bottom left front corner's z value.</param>
            <param name="maxX">Upper right back corner's x value.</param>
            <param name="maxY">Upper right back corner's y value.</param>
            <param name="maxZ">Upper right back corner's z value.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid3D`1.Resize(System.Int32,System.Int32,System.Int32)">
            <summary>
            Resizes the Grid to the given size, keeping data the same but any new cells will be set to <see cref="P:Archon.SwissArmyLib.Collections.Grid3D`1.DefaultValue"/>.
            </summary>
            <param name="width">The new width.</param>
            <param name="height">The new height.</param>
            <param name="depth">The new depth.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Collections.PrioritizedItem`1">
            <summary>
            Represents an item and its priority.
            </summary>
            <typeparam name="T">The type of the item.</typeparam>
        </member>
        <member name="F:Archon.SwissArmyLib.Collections.PrioritizedItem`1.Item">
            <summary>
            The item that is prioritized.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Collections.PrioritizedItem`1.Priority">
            <summary>
            The priority of the item.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedItem`1.#ctor(`0,System.Int32)">
            <summary>
            Creates a new prioritized item.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Collections.PrioritizedList`1">
            <summary>
            A list of items sorted by their priority.
            
            <remarks>
                Currently it's unintuitively only sorted ascendingly. Sorry.
            </remarks>
            </summary>
            <typeparam name="T">The type of the prioritized items.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.PrioritizedList`1.Count">
            <summary>
            Gets the amount of items in the list.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.PrioritizedList`1.Item(System.Int32)">
            <summary>
            Gets the item at the specified index.
            </summary>
            <param name="index">The index for the item to retrieve.</param>
            <returns>The item at the specified index.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Add(Archon.SwissArmyLib.Collections.PrioritizedItem{`0})">
            <summary>
            Adds a prioritized item to the list.
            </summary>
            <param name="item">The prioritized item to add.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Add(`0)">
            <summary>
            Adds an item to the list with priority 0.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Add(`0,System.Int32)">
            <summary>
            Adds an item to the list with the specified priority.
            </summary>
            <param name="item">The item to add.</param>
            <param name="priority">The priority to give the item.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Remove(Archon.SwissArmyLib.Collections.PrioritizedItem{`0})">
            <summary>
            Removes a prioritized item from the list.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>True if found and removed, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Remove(`0)">
            <summary>
            Removes an item from the list.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>True if found and removed, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item found at the specified index.
            </summary>
            <param name="index">The index of the item to remove.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Clear">
            <summary>
            Clears all items from the list.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Contains(Archon.SwissArmyLib.Collections.PrioritizedItem{`0})">
            <summary>
            Checks whether the list contains the specified prioritized item.
            </summary>
            <param name="item">The item to check if the list contains.</param>
            <returns>True if found, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.Contains(`0)">
            <summary>
            Checks whether the list contains the specified item.
            </summary>
            <param name="item">The item to check if the list contains.</param>
            <returns>True if found, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.CopyTo(Archon.SwissArmyLib.Collections.PrioritizedItem{`0}[],System.Int32)">
            <summary>
            Copies the list prioritized items to an array starting at the specified index.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="arrayIndex">The index to start at.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the list items to an array starting at the specified index.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="arrayIndex">The index to start at.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.IndexOf(Archon.SwissArmyLib.Collections.PrioritizedItem{`0})">
            <summary>
            Gets the index of a prioritized item in the list.
            </summary>
            <param name="item">The item to get the index for.</param>
            <returns>The index of the item in the list or -1 if not found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.IndexOf(`0)">
            <summary>
            Gets the index of a item in the list.
            </summary>
            <param name="item">The item to get the index for.</param>
            <returns>The index of the item in the list or -1 if not found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.PrioritizedList`1.GetEnumerator">
            <summary>
            Gets an enumerator for the list items.
            </summary>
            <returns>The enumerator.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Collections.Grid2D`1">
            <summary>
            A generic two-dimensional grid.
            
            <seealso cref="T:Archon.SwissArmyLib.Collections.Grid3D`1"/>
            </summary>
            <typeparam name="T">The type of content cells can contain.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid2D`1.Width">
            <summary>
            Gets the width (number of columns) of the grid.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid2D`1.Height">
            <summary>
            Gets the height (number of rows) of the grid.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid2D`1.DefaultValue">
            <summary>
            Gets or sets the default values used for clearing or initializing new cells.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Collections.Grid2D`1.Item(System.Int32,System.Int32)">
            <summary>
            Gets or sets the value of the cell located at the specified coordinate.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns>The contents of the cell.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new 2D Grid with the specified width and height. 
            Cells will be initialized with their type's default value.
            </summary>
            <param name="width">Number of columns</param>
            <param name="height">Number of rows</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.#ctor(System.Int32,System.Int32,`0)">
            <summary>
            Creates a new 2D Grid with the specified width and height. 
            Cells will be initialized with the value of <paramref name="defaultValue"/>.
            </summary>
            <param name="width">Number of columns</param>
            <param name="height">Number of rows</param>
            <param name="defaultValue">The value used for initializing new cells.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.Get(System.Int32,System.Int32)">
            <summary>
            Gets the value of the cell located at the specified coordinate.
            
            <seealso cref="P:Archon.SwissArmyLib.Collections.Grid2D`1.Item(System.Int32,System.Int32)"/>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns>The cell contents.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.Set(System.Int32,System.Int32,`0)">
            <summary>
            Sets the value of the cell located at the specified coordinate.
            
            <seealso cref="P:Archon.SwissArmyLib.Collections.Grid2D`1.Item(System.Int32,System.Int32)"/>
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="value">The value to set the cell to.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.Clear">
            <summary>
            Clears the grid, setting every cell to <see cref="P:Archon.SwissArmyLib.Collections.Grid2D`1.DefaultValue"/>.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.Clear(`0)">
            <summary>
            Clears the grid, setting every cell to the given value.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.Fill(`0,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Fills everything in the specified rectangle to the given value.
            </summary>
            <param name="value">The value to fill the cells with.</param>
            <param name="minX">Bottom left corner's x value.</param>
            <param name="minY">Bottom left corner's y value.</param>
            <param name="maxX">Upper right corner's x value.</param>
            <param name="maxY">Upper right corner's y value.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Collections.Grid2D`1.Resize(System.Int32,System.Int32)">
            <summary>
            Resizes the Grid to the given size, keeping data the same but any new cells will be set to <see cref="P:Archon.SwissArmyLib.Collections.Grid2D`1.DefaultValue"/>.
            </summary>
            <param name="width">The new width.</param>
            <param name="height">The new height.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Event">
            <summary>
            A simple event handler that uses interfaces instead of delegates to avoid the garbage generated by them.
            
            This is the parameterless version. 
            See <see cref="T:Archon.SwissArmyLib.Events.Event`1"/> if you need to send data with the event.
            
            Listeners are required to implement the <see cref="T:Archon.SwissArmyLib.Events.IEventListener"/> interface.
            
            Events are differentiated by an integer. You are expected to create constants to define your events and make them unique.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Event.Id">
            <summary>
            Gets the ID of this event.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.#ctor(System.Int32)">
            <summary>
            Creates a new Event with the specified ID.
            </summary>
            <param name="id">The id of the event.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.AddListener(Archon.SwissArmyLib.Events.IEventListener,System.Int32)">
            <summary>
            Adds a listener for the event with an optional call-order priority.
            </summary>
            <param name="listener">The listener to add.</param>
            <param name="priority">The priority of the listener compared to other listeners. Controls whether the listener is called before or after other listeners.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.RemoveListener(Archon.SwissArmyLib.Events.IEventListener)">
            <summary>
            Removes a listener from the event.
            </summary>
            <param name="listener">The listener to remove</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.Invoke">
            <summary>
            Notifies all listeners that the event occured.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event.Clear">
            <summary>
            Clears all listeners
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.Event`1">
            <summary>
            A simple event handler that uses interfaces instead of delegates to avoid the garbage generated by them.
            
            This is the parameterized version. 
            See <see cref="T:Archon.SwissArmyLib.Events.Event"/> if you don't need to send data with the event.
            
            Listeners are required to implement the <see cref="T:Archon.SwissArmyLib.Events.IEventListener`1"/> interface.
            
            Events are differentiated by an integer. You are expected to create constants to define your events and make them unique.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.Event`1.Id">
            <summary>
            Gets the ID of this event.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.#ctor(System.Int32)">
            <summary>
            Creates a new Event with the specified ID.
            </summary>
            <param name="id">The id of the event.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.AddListener(Archon.SwissArmyLib.Events.IEventListener{`0},System.Int32)">
            <summary>
            Adds a listener for the event with an optional call-order priority.
            </summary>
            <param name="listener">The listener to add.</param>
            <param name="priority">The priority of the listener compared to other listeners. Controls whether the listener is called before or after other listeners.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.RemoveListener(Archon.SwissArmyLib.Events.IEventListener{`0})">
            <summary>
            Removes a listener from the event.
            </summary>
            <param name="listener">The listener to remove</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.Invoke(`0)">
            <summary>
            Notifies all listeners that the event occured.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.Event`1.Clear">
            <summary>
            Clears all listeners
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.GlobalEvents">
            <summary>
            A manager of events that do not belong to any specific object but instead can be listened to by anyone and invoked by anyone.
            
            Useful for GameLoaded, MatchEnded and similar events.
            
            This uses <see cref="T:Archon.SwissArmyLib.Events.Event"/> which in turn uses interface instead of delegates in order to avoid the often short-lived memory they allocate.
            
            This version is for parameterless events. 
            See <see cref="T:Archon.SwissArmyLib.Events.GlobalEvents`1"/> if you need to send data with the events.
            
            Events are differentiated by an integer. You are expected to create constants to define your events.
            
            <seealso cref="T:Archon.SwissArmyLib.Events.IEventListener"/>
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.Invoke(System.Int32)">
            <summary>
            Invokes an event.
            </summary>
            <param name="eventId">The id of the event.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.AddListener(System.Int32,Archon.SwissArmyLib.Events.IEventListener,System.Int32)">
            <summary>
            Adds a listener for an event.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="listener">The listener to be called.</param>
            <param name="priority">The priority of the listener which affects the order which listeners are called in.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.RemoveListener(System.Int32,Archon.SwissArmyLib.Events.IEventListener)">
            <summary>
            Removes a listener for an event.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="listener">The listener to remove.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.RemoveListener(Archon.SwissArmyLib.Events.IEventListener)">
            <summary>
            Removes the specified listener from all events.
            </summary>
            <param name="listener">The listener to unsubscribe from all events.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.Clear">
            <summary>
            Clears all listeners for all events.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents.Clear(System.Int32)">
            <summary>
            Clears all listeners for a single event.
            </summary>
            <param name="eventId">The id of the event.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.GlobalEvents`1">
            <summary>
            A manager of events that do not belong to any specific object but instead can be listened to by anyone and invoked by anyone.
            
            Useful for GameLoaded, MatchEnded and similar events.
            
            This uses <see cref="T:Archon.SwissArmyLib.Events.Event"/> which in turn uses interface instead of delegates in order to avoid the often short-lived memory they allocate.
            
            This version is for events with args. 
            See <see cref="T:Archon.SwissArmyLib.Events.GlobalEvents"/> if you need to send data with the events.
            
            Events are differentiated by an integer. You are expected to create constants to define your events.
            
            <seealso cref="T:Archon.SwissArmyLib.Events.IEventListener`1"/>
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.Invoke(System.Int32,`0)">
            <summary>
            Invokes an event.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="args">The event args.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.AddListener(System.Int32,Archon.SwissArmyLib.Events.IEventListener{`0},System.Int32)">
            <summary>
            Adds a listener for an event.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="listener">The listener to be called.</param>
            <param name="priority">The priority of the listener which affects the order which listeners are called in.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.RemoveListener(System.Int32,Archon.SwissArmyLib.Events.IEventListener{`0})">
            <summary>
            Removes a listener for an event.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="listener">The listener to remove.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.RemoveListener(Archon.SwissArmyLib.Events.IEventListener{`0})">
            <summary>
            Removes the specified listener from all events.
            </summary>
            <param name="listener">The listener to unsubscribe from all events.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.Clear">
            <summary>
            Clears all listeners for all events.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.GlobalEvents`1.Clear(System.Int32)">
            <summary>
            Clears all listeners for a single event.
            </summary>
            <param name="eventId">The id of the event.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.IEventListener">
            <summary>
            Defines a method to be used for event callbacks.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.IEventListener.OnEvent(System.Int32)">
            <summary>
            Called when an event is invoked.
            </summary>
            <param name="eventId">The id of the event.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.IEventListener`1">
            <summary>
            Defines a method to be used for event callbacks with a parameter of type <typeparamref name="TArgs"/>.
            </summary>
            <typeparam name="TArgs"></typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.IEventListener`1.OnEvent(System.Int32,`0)">
            <summary>
            Called when an event is invoked.
            </summary>
            <param name="eventId">The id of the event.</param>
            <param name="args">The args for the event.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.ManagedUpdate">
            <summary>
            A relay for Unity update events.
            Here's why you might want to use this:
            https://blogs.unity3d.com/2015/12/23/1k-update-calls/
            In short; avoid overhead of Native C++ --> Managed C# calls.
            
            Also useful for non-MonoBehaviours that needs to be part of the update loop as well.
            
            Events your can subscribe to:
                <see cref="F:Archon.SwissArmyLib.Events.ManagedUpdate.OnUpdate"/>
                <see cref="F:Archon.SwissArmyLib.Events.ManagedUpdate.OnLateUpdate"/>
                <see cref="F:Archon.SwissArmyLib.Events.ManagedUpdate.OnFixedUpdate"/>
            
            <seealso cref="T:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour"/>
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.ManagedUpdate.OnUpdate">
            <summary>
            Event handler that is called every update.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.ManagedUpdate.OnLateUpdate">
            <summary>
            Event handler that is called every update but after the regular Update.
            <seealso cref="F:Archon.SwissArmyLib.Events.ManagedUpdate.OnUpdate"/>
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.ManagedUpdate.OnFixedUpdate">
            <summary>
            Event handler that is called every fixed update.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.ManagedUpdate.EventIds">
            <summary>
            Relayed event ids.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour">
            <summary>
            A subclass of MonoBehaviour that uses <see cref="T:Archon.SwissArmyLib.Events.ManagedUpdate"/> for update events.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.ExecutionOrder">
            <summary>
            Affects whether this components' events will be called before or after others'.
            
            Basically a reimplementation of Unity's ScriptExecutionOrder.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.UsesUpdate">
            <summary>
            Whether you want to use <see cref="M:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.OnUpdate"/>.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.UsesLateUpdate">
            <summary>
            Whether you want to use <see cref="M:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.OnLateUpdate"/>.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.UsesFixedUpdate">
            <summary>
            Whether you want to use <see cref="M:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.OnFixedUpdate"/>.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.Start">
            <summary>
            Start is called on the frame when a script is enabled just before any of the Update methods is called the first time.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.OnEnable">
            <summary>
            Called when the component is enabled.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.OnDisable">
            <summary>
            Called when the component is disabled.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.OnEvent(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.OnUpdate">
            <summary>
            Called every frame if <see cref="P:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.UsesUpdate"/> is true and the component is enabled.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.OnLateUpdate">
            <summary>
            Called every frame just after <see cref="M:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.OnUpdate"/> if <see cref="P:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.UsesLateUpdate"/> is true and the component is enabled.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.OnFixedUpdate">
            <summary>
            This function is called every fixed framerate frame if <see cref="M:Archon.SwissArmyLib.Events.ManagedUpdateBehaviour.OnFixedUpdate"/> is true and the component is enabled.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.TellMeWhen">
            <summary>
            A utility class for getting notified after a specific amount of time.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Events.TellMeWhen.NoId">
            <summary>
            Default id, if none is supplied
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.Exact(System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object)">
            <summary>
            Schedule a callback to be called at a specific <see cref="P:UnityEngine.Time.time"/>.
            </summary>
            <param name="time">The <see cref="P:UnityEngine.Time.time"/> at which the callback should be called.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.Exact(System.Single,System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object)">
            <summary>
            Schedule a callback to be called at a specific <see cref="P:UnityEngine.Time.time"/> and repeatedly every <paramref name="repeatInterval"/> there after.
            </summary>
            <param name="time">The <see cref="P:UnityEngine.Time.time"/> at which the callback should be called.</param>
            <param name="repeatInterval">The interval in seconds to repeat the timer.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.Seconds(System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object,System.Boolean)">
            <summary>
            Schedule a callback to be called after a specific amount of (scaled) seconds.
            </summary>
            <param name="seconds">The amount of seconds before the callback should be called.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
            <param name="repeating">Whether the timer should repeat untill cancelled.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.Minutes(System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object,System.Boolean)">
            <summary>
            Schedule a callback to be called after a specific amount of (scaled) minutes.
            </summary>
            <param name="minutes">The amount of minutes before the callback should be called.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
            <param name="repeating">Whether the timer should repeat untill cancelled.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.ExactUnscaled(System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object)">
            <summary>
            Schedule a callback to be called at a specific <see cref="P:UnityEngine.Time.unscaledTime"/>.
            </summary>
            <param name="time">The <see cref="P:UnityEngine.Time.unscaledTime"/> at which the callback should be called.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.ExactUnscaled(System.Single,System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object)">
            <summary>
            Schedule a callback to be called at a specific <see cref="P:UnityEngine.Time.unscaledTime"/> and repeatedly every <paramref name="repeatInterval"/> there after.
            </summary>
            <param name="time">The <see cref="P:UnityEngine.Time.unscaledTime"/> at which the callback should be called.</param>
            <param name="repeatInterval">The interval in seconds to repeat the timer.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.SecondsUnscaled(System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object,System.Boolean)">
            <summary>
            Schedule a callback to be called after a specific amount of (unscaled) seconds.
            </summary>
            <param name="seconds">The amount of seconds before the callback should be called.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
            <param name="repeating">Whether the timer should repeat untill cancelled.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.MinutesUnscaled(System.Single,Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32,System.Object,System.Boolean)">
            <summary>
            Schedule a callback to be called after a specific amount of (unscaled) minutes.
            </summary>
            <param name="minutes">The amount of minutes before the callback should be called.</param>
            <param name="callback">The callback that will be notified.</param>
            <param name="id">An id so that you can reidentify the origin of the timer. Optional, but useful if you have more than one timer.</param>
            <param name="args">An optional args object that will be passed to the callback.</param>
            <param name="repeating">Whether the timer should repeat untill cancelled.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.CancelScaled(Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback)">
            <summary>
            Cancels all scaled timers for the given callback.
            </summary>
            <param name="callback">The callback of the timers to cancel.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.CancelScaled(Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32)">
            <summary>
            Cancels a scaled timer for the given callback with a specific id.
            </summary>
            <param name="callback">The callback of the timer to cancel.</param>
            <param name="id">The id of the timer to cancel.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.CancelUnscaled(Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback)">
            <summary>
            Cancels all unscaled timers for the given callback.
            </summary>
            <param name="callback">The callback of the timers to cancel.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.CancelUnscaled(Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback,System.Int32)">
            <summary>
            Cancels a unscaled timer for the given callback with a specific id.
            </summary>
            <param name="callback">The callback of the timer to cancel.</param>
            <param name="id">The id of the timer to cancel.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.CancelAll">
            <summary>
            Cancels all (both scaled and unscaled) timers for all callbacks.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback">
            <summary>
            Defines a method to be used for timer events.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Events.TellMeWhen.ITimerCallback.OnTimesUp(System.Int32,System.Object)">
            <summary>
            Called when a timer is triggered (eg. after X amount of time).
            </summary>
            <param name="id">The id of the timer.</param>
            <param name="args">The supplied event args if supplied when the timer was scheduled.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Gravity.GravitationalEntity">
            <summary>
            Makes this <see cref="T:UnityEngine.GameObject"/>'s <see cref="T:UnityEngine.Rigidbody"/> part of the gravitational system.
            
            For 2D physics see <see cref="T:Archon.SwissArmyLib.Gravity.GravitationalEntity2D"/>.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Gravity.IGravitationalAffecter">
            <summary>
            Represents a gravitational pull on entities.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.IGravitationalAffecter.GetForceAt(UnityEngine.Vector3)">
            <summary>
            Calculates how much gravitational pull is at a specific location caused by this affecter.
            </summary>
            <param name="location">The location to test.</param>
            <returns>A vector representing the force at <paramref name="location"/>.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint">
            <summary>
            A sphere-shaped gravitational point.
            
            <remarks>The force is currently constant and not dependent on how close the entities are.</remarks>
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint.Strength">
            <summary>
            The gravitational pull of this point.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint.Radius">
            <summary>
            Gets or sets the radius of this gravitational point.
            
            <remarks>If <see cref="P:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint.IsGlobal"/> is true, then this property is ignored.</remarks>
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint.DropoffCurve">
            <summary>
            Gets or sets the dropoff curve of the gravitational force.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint.IsGlobal">
            <summary>
            Gets or sets whether this point should affect all entities regardless of whether they're in range.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint.GetForceAt(UnityEngine.Vector3)">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Gravity.GravitationalEntity2D">
            <summary>
            Makes this <see cref="T:UnityEngine.GameObject"/>'s <see cref="T:UnityEngine.Rigidbody2D"/> part of the gravitational system.
            
            For 3D physics see <see cref="T:Archon.SwissArmyLib.Gravity.GravitationalEntity"/>.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Gravity.GravitationalSystem">
            <summary>
            A gravitational system to allow for a more flexible gravity instead of just a constant directional gravity.
            
            Useful for planets, black holes, magnets etc.
            
            Rigidbodies that should be affected should have the <see cref="T:Archon.SwissArmyLib.Gravity.GravitationalEntity"/> component (or <see cref="T:Archon.SwissArmyLib.Gravity.GravitationalEntity2D"/> if using 2d physics).
            
            Add gravitational forces by implementing the <see cref="T:Archon.SwissArmyLib.Gravity.IGravitationalAffecter"/> interface and registering it in the system.
            See <see cref="T:Archon.SwissArmyLib.Gravity.SphericalGravitationalPoint"/> for a simple example implementation.
            
            <remarks>You might want to set Unity's gravity to (0,0,0).</remarks>
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.Register(Archon.SwissArmyLib.Gravity.IGravitationalAffecter)">
            <summary>
            Registers a gravitational affecter to be part of the system.
            </summary>
            <param name="affecter">The affecter to register.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.Register(UnityEngine.Rigidbody)">
            <summary>
            Registers a <see cref="T:UnityEngine.Rigidbody"/> that should be affected by gravitational forces in this system.
            </summary>
            <param name="rigidbody">The rigidbody to register.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.Register(UnityEngine.Rigidbody2D)">
            <summary>
            Registers a <see cref="T:UnityEngine.Rigidbody2D"/> that should be affected by gravitational forces in this system.
            </summary>
            <param name="rigidbody">The rigidbody to register.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.Unregister(Archon.SwissArmyLib.Gravity.IGravitationalAffecter)">
            <summary>
            Unregisters a gravitational affecter from the system, so it no longer affects entities.
            </summary>
            <param name="affecter">The affecter to unregister.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.Unregister(UnityEngine.Rigidbody)">
            <summary>
            Unregisters a <see cref="T:UnityEngine.Rigidbody"/> from the system, so it no longer is affected by gravitational forces in this system.
            </summary>
            <param name="rigidbody">The rigidbody to unregister.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.Unregister(UnityEngine.Rigidbody2D)">
            <summary>
            Unregisters a <see cref="T:UnityEngine.Rigidbody2D"/> from the system, so it no longer is affected by gravitational forces in this system.
            </summary>
            <param name="rigidbody">The rigidbody to unregister.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Gravity.GravitationalSystem.GetGravityAtPoint(UnityEngine.Vector3)">
            <summary>
            Gets the sum of all gravitational forces at a specific location.
            </summary>
            <param name="location">The location to test.</param>
            <returns>A vector representing the sum of gravitational force at <paramref name="location"/>.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Partitioning.Bin2D`1">
            <summary>
            A simple GC-friendly two-dimensional <see href="https://en.wikipedia.org/wiki/Bin_(computational_geometry)">Bin (aka Spatial Grid)</see> implementation.
            
            When you're done with the Bin, you should <see cref="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Dispose"/> it so its resources can be freed in their object pool. If you forget this, no harm will be done but memory will be GC'ed.
            
            <seealso cref="T:Archon.SwissArmyLib.Partitioning.Bin3D`1"/>
            </summary>
            <typeparam name="T">The type of items this Bin will hold.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin2D`1.Width">
            <summary>
            Gets the width (number of columns) of the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin2D`1.Height">
            <summary>
            Gets the height (number of rows) of the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin2D`1.CellWidth">
            <summary>
            Gets the width of cells in the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin2D`1.CellHeight">
            <summary>
            Gets the height of cells in the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin2D`1.Item(System.Int32,System.Int32)">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1"/> for the items in the given cell.
            </summary>
            <param name="x">The x coordinate of the cell.</param>
            <param name="y">The y coordinate of the cell.</param>
            <returns></returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.#ctor(System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            Creates a new Bin.
            </summary>
            <param name="gridWidth">The width of the grid.</param>
            <param name="gridHeight">The height of the grid.</param>
            <param name="cellWidth">The width of a cell.</param>
            <param name="cellHeight">The height of a cell.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Insert(`0,UnityEngine.Rect)">
            <summary>
            Inserts an item with the given bounds into the Bin.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="bounds">The bounds of the item.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Remove(`0,UnityEngine.Rect)">
            <summary>
            Removes an item which was inserted with the given bounds from the Bin.
            </summary>
            <param name="item">The item to remove.</param>
            <param name="bounds">The bounds that the item was inserted with.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Update(`0,UnityEngine.Rect,UnityEngine.Rect)">
            <summary>
            Removes and reinserts an item with new bounds, essentially moving it.
            </summary>
            <param name="item">The item to update.</param>
            <param name="prevBounds">The bounds that the item was inserted with earlier.</param>
            <param name="newBounds">The new bounds to insert the item with.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Retrieve(UnityEngine.Rect,System.Collections.Generic.HashSet{`0})">
            <summary>
            Gets all items in the Bin that could potentially intersect with the given bounds.
            </summary>
            <param name="bounds">The bounds to check for.</param>
            <param name="results">Where to add results to.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Clear">
            <summary>
            Removes all items from the Bin.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin2D`1.Dispose">
            <summary>
            Frees (clears) used resources that can be recycled. 
            
            Call this when you're done with the Bin.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Partitioning.Bin3D`1">
            <summary>
            A simple GC-friendly three-dimensional <see href="https://en.wikipedia.org/wiki/Bin_(computational_geometry)">Bin (aka Spatial Grid)</see> implementation.
            
            When you're done with the Bin, you should <see cref="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Dispose"/> it so its resources can be freed in their object pool. If you forget this, no harm will be done but memory will be GC'ed.
            
            <seealso cref="T:Archon.SwissArmyLib.Partitioning.Bin2D`1"/>
            </summary>
            <typeparam name="T">The type of items this Bin will hold.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.Width">
            <summary>
            Gets the width (number of columns) of the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.Height">
            <summary>
            Gets the height (number of rows) of the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.Depth">
            <summary>
            Gets the depth (number of layers) of the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.CellWidth">
            <summary>
            Gets the width of cells in the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.CellHeight">
            <summary>
            Gets the height of cells in the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.CellDepth">
            <summary>
            Gets the depth of cells in the Bin.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Bin3D`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1"/> for the items in the given cell.
            </summary>
            <param name="x">The x coordinate of the cell.</param>
            <param name="y">The y coordinate of the cell.</param>
            <param name="z">The z coordinate of the cell.</param>
            <returns></returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.#ctor(System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Creates a new Bin.
            </summary>
            <param name="gridWidth">The width of the grid.</param>
            <param name="gridHeight">The height of the grid.</param>
            <param name="gridDepth">The depth of the grid.</param>
            <param name="cellWidth">The width of a cell.</param>
            <param name="cellHeight">The height of a cell.</param>
            <param name="cellDepth">The depth of a cell.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Insert(`0,UnityEngine.Bounds)">
            <summary>
            Inserts an item with the given bounds into the Bin.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="bounds">The bounds of the item.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Remove(`0,UnityEngine.Bounds)">
            <summary>
            Removes an item which was inserted with the given bounds from the Bin.
            </summary>
            <param name="item">The item to remove.</param>
            <param name="bounds">The bounds that the item was inserted with.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Update(`0,UnityEngine.Bounds,UnityEngine.Bounds)">
            <summary>
            Removes and reinserts an item with new bounds, essentially moving it.
            </summary>
            <param name="item">The item to update.</param>
            <param name="prevBounds">The bounds that the item was inserted with earlier.</param>
            <param name="newBounds">The new bounds to insert the item with.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Retrieve(UnityEngine.Bounds,System.Collections.Generic.HashSet{`0})">
            <summary>
            Gets all items in the Bin that could potentially intersect with the given bounds.
            </summary>
            <param name="bounds">The bounds to check for.</param>
            <param name="results">Where to add results to.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Clear">
            <summary>
            Removes all items from the Bin.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Bin3D`1.Dispose">
            <summary>
            Frees (clears) used resources that can be recycled. 
            
            Call this when you're done with the Bin.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Partitioning.Octree`1">
            <summary>
            A GC-friendly <see href="https://en.wikipedia.org/wiki/Octree">Octree</see> implementation.
            
            Use the static <see cref="M:Archon.SwissArmyLib.Partitioning.Octree`1.Create(UnityEngine.Bounds,System.Int32,System.Int32)"/> and <see cref="M:Archon.SwissArmyLib.Partitioning.Octree`1.Destroy(Archon.SwissArmyLib.Partitioning.Octree{`0})"/> methods for creating and destroying trees.
            If you forget to <see cref="M:Archon.SwissArmyLib.Partitioning.Octree`1.Destroy(Archon.SwissArmyLib.Partitioning.Octree{`0})"/> a tree when you're done with it, it will instead be collected 
            by the GC as normal, but the nodes will not be recycled.
            </summary>
            <typeparam name="T">The type of items this octree should hold.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Create(UnityEngine.Bounds,System.Int32,System.Int32)">
            <summary>
            Creates an Octree.
            </summary>
            <param name="bounds">The size of the tree's bounds.</param>
            <param name="maxItems">The amount of items a node can contain before splitting.</param>
            <param name="maxDepth">The maximum depth</param>
            <returns>The octree.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Destroy(Archon.SwissArmyLib.Partitioning.Octree{`0})">
            <summary>
            Destroys a tree, making it available for being recycled.
            
            Do not use the tree again after calling this.
            </summary>
            <param name="tree">The tree to destroy.</param>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Octree`1.Bounds">
            <summary>
            Gets the bounds of this octree node.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Octree`1.Depth">
            <summary>
            Gets the depth of this octree node.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Octree`1.MaxDepth">
            <summary>
            Gets the maximum depth that the octree can go.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Octree`1.MaxItems">
            <summary>
            Gets the maximum amount of items this node can contain before splitting.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Octree`1.IsSplit">
            <summary>
            Gets whether this node has been split.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Octree`1.Count">
            <summary>
            Gets the total amount of items from this node and down.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Insert(`0,UnityEngine.Bounds)">
            <summary>
            Inserts an item with the specified bounds into the octree.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="bounds">The bounds of the item, used to place it correctly in the tree.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Remove(`0,UnityEngine.Bounds)">
            <summary>
            Removes an item with the specified bounds from the octree.
            </summary>
            <param name="item">The item to remove.</param>
            <param name="bounds">The bounds used for previously inserting this item.</param>
            <returns>True if item was found and removed, otherwise false.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Retrieve(UnityEngine.Bounds)">
            <summary>
            Retrieves all potential matches for the given <see cref="P:Archon.SwissArmyLib.Partitioning.Octree`1.Bounds"/>.
            
            Careful, this method creates a new <see cref="T:System.Collections.Generic.HashSet`1"/>. 
            You might want to use <see cref="M:Archon.SwissArmyLib.Partitioning.Octree`1.Retrieve(UnityEngine.Bounds,System.Collections.Generic.HashSet{`0})"/> instead if you call this often.
            </summary>
            <param name="bounds"></param>
            <returns>Potential matches.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Retrieve(UnityEngine.Bounds,System.Collections.Generic.HashSet{`0})">
            <summary>
            Retrieves all potential matches for the given <see cref="P:Archon.SwissArmyLib.Partitioning.Octree`1.Bounds"/> and adds them to <paramref name="results"/>.
            </summary>
            <param name="bounds"></param>
            <param name="results">Where results will be added to.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Clear">
            <summary>
            Clears all items in this node and removes subnodes.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Octree`1.Dispose">
            <summary>
            Destroys the octree using <see cref="M:Archon.SwissArmyLib.Partitioning.Octree`1.Destroy(Archon.SwissArmyLib.Partitioning.Octree{`0})"/>.
            
            Do not use the tree after calling this!
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Partitioning.Quadtree`1">
            <summary>
            A GC-friendly <see href="https://en.wikipedia.org/wiki/Quadtree">Quadtree</see> implementation.
            
            Use the static <see cref="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Create(UnityEngine.Rect,System.Int32,System.Int32)"/> and <see cref="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Destroy(Archon.SwissArmyLib.Partitioning.Quadtree{`0})"/> methods for creating and destroying trees.
            If you forget to <see cref="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Destroy(Archon.SwissArmyLib.Partitioning.Quadtree{`0})"/> a tree when you're done with it, it will instead be collected 
            by the GC as normal, but the nodes will not be recycled.
            </summary>
            <typeparam name="T">The type of items this quadtree should hold.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Create(UnityEngine.Rect,System.Int32,System.Int32)">
            <summary>
            Creates a Quadtree.
            </summary>
            <param name="bounds">The size of the tree's bounds.</param>
            <param name="maxItems">The amount of items a node can contain before splitting.</param>
            <param name="maxDepth">The maximum depth</param>
            <returns>The quadtree.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Destroy(Archon.SwissArmyLib.Partitioning.Quadtree{`0})">
            <summary>
            Destroys a tree, making it available for being recycled.
            
            Do not use the tree again after calling this.
            </summary>
            <param name="tree">The tree to destroy.</param>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Quadtree`1.Bounds">
            <summary>
            Gets the bounds of this quadtree node.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Quadtree`1.Depth">
            <summary>
            Gets the depth of this quadtree node.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Quadtree`1.MaxDepth">
            <summary>
            Gets the maximum depth that the quadtree can go.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Quadtree`1.MaxItems">
            <summary>
            Gets the maximum amount of items this node can contain before splitting.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Quadtree`1.IsSplit">
            <summary>
            Gets whether this node has been split.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Partitioning.Quadtree`1.Count">
            <summary>
            Gets the total amount of items from this node and down.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Insert(`0,UnityEngine.Rect)">
            <summary>
            Inserts an item with the specified bounds into the quadtree.
            </summary>
            <param name="item">The item to insert.</param>
            <param name="bounds">The bounds of the item, used to place it correctly in the tree.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Remove(`0,UnityEngine.Rect)">
            <summary>
            Removes an item with the specified bounds from the quadtree.
            </summary>
            <param name="item">The item to remove.</param>
            <param name="bounds">The bounds used for previously inserting this item.</param>
            <returns>True if item was found and removed, otherwise false.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Retrieve(UnityEngine.Rect)">
            <summary>
            Retrieves all potential matches for the given <see cref="T:UnityEngine.Rect"/>.
            
            Careful, this method creates a new <see cref="T:System.Collections.Generic.HashSet`1"/>. 
            You might want to use <see cref="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Retrieve(UnityEngine.Rect,System.Collections.Generic.HashSet{`0})"/> instead if you call this often.
            </summary>
            <param name="rect"></param>
            <returns>Potential matches.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Retrieve(UnityEngine.Rect,System.Collections.Generic.HashSet{`0})">
            <summary>
            Retrieves all potential matches for the given <see cref="T:UnityEngine.Rect"/> and adds them to <paramref name="results"/>.
            </summary>
            <param name="rect"></param>
            <param name="results">Where results will be added to.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Clear">
            <summary>
            Clears all items in this node and removes subnodes.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Dispose">
            <summary>
            Destroys the quadtree using <see cref="M:Archon.SwissArmyLib.Partitioning.Quadtree`1.Destroy(Archon.SwissArmyLib.Partitioning.Quadtree{`0})"/>.
            
            Do not use the tree after calling this!
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Pooling.PoolableGroup">
            <summary>
            Manages a list of IPoolable components found in the hierarchy of this GameObject and notifies them when it is spawned and despawned.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolableGroup.AddManually(Archon.SwissArmyLib.Pooling.IPoolable)">
            <summary>
            Manually add a poolable object to be notified when this component is spawned or despawned.
            
            Useful if you dynamically add IPoolable components at runtime.
            </summary>
            <param name="poolable">The poolable object that should be notified.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolableGroup.RemoveManually(Archon.SwissArmyLib.Pooling.IPoolable)">
            <summary>
            Manually removes a poolable object so that it no longer is notified when this component is spawned or despawned.
            </summary>
            <param name="poolable">The poolable object that should no longer be notified.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Pooling.GameObjectPool`1">
            <summary>
            An object pool that can recycle prefab instances.
            </summary>
            <typeparam name="T">The type of the component on the prefab.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Pooling.GameObjectPool`1.Prefab">
            <summary>
            Gets the prefab used to instantiate GameObjects.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.#ctor(`0)">
            <summary>
            Creates a new GameObject pool for the specified prefab.
            </summary>
            <param name="prefab">The prefab used for instantiating instances.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.#ctor(System.String,System.Func{`0})">
            <summary>
            Creates a new GameObject pool with a custom name and a factory method used for instantiating instances.
            </summary>
            <param name="name">The name of the pool.</param>
            <param name="create">The factory method used to instantiating instances.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.Spawn">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.Spawn(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Transform)">
            <summary>
            Spawns a recycled object if there's one available, otherwise creates a new instance.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.GameObjectPool`1.Despawn(`0)">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Pooling.IPool`1">
            <summary>
            Represents an object pool that has methods for spawning and despawning objects.
            </summary>
            <typeparam name="T">The type of objects that this pool can be used for.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.IPool`1.Spawn">
            <summary>
            Spawns a recycled or new instance of the type <typeparamref name="T"/>.
            </summary>
            <returns>The spawned instance.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.IPool`1.Despawn(`0)">
            <summary>
            Despawns an instance of the type <typeparamref name="T"/> and marks it for reuse.
            </summary>
            <param name="target">The instance to despawn.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Pooling.IPoolable">
            <summary>
            Represents an object that can be recycled in an <see cref="T:Archon.SwissArmyLib.Pooling.IPool`1"/> and should be notified when it's spawned and despawned.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.IPoolable.OnSpawned">
            <summary>
            Called when the object is spawned (either fresh or recycled).
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.IPoolable.OnDespawned">
            <summary>
            Called when the object is despawned and marked for recycling.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Pooling.Pool`1">
            <summary>
            An object pool that can recycle objects of the type <typeparamref name="T"/>.
            
            If the type implements <see cref="T:Archon.SwissArmyLib.Pooling.IPoolable"/> they will be notified when they're spawned and despawned.
            </summary>
            <typeparam name="T">The type of objects this object pool should contain.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.#ctor(System.Func{`0})">
            <summary>
            Creates a new object pool that uses the specified factory method to create object instances.
            </summary>
            <param name="create">Factory method to use for creating new instances.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.Prewarm(System.Int32)">
            <summary>
            Fills the pool with objects so that it contains the specified amount of objects.
            
            If it already contains the specified amount or more, nothing will be done.
            </summary>
            <param name="targetCount"></param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.Spawn">
            <summary>
            Spawns a recycled object if there's one available, otherwise creates a new instance.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.Despawn(`0)">
            <summary>
            Despawns an object, adding it back to the pool.
            </summary>
            <param name="target">The object to despawn.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.OnSpawned(`0)">
            <summary>
            Called when an object has been spawned and removed from the pool.
            </summary>
            <param name="target">The spawned object.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.OnDespawned(`0)">
            <summary>
            Called when an object has been despawned and placed back in the pool.
            </summary>
            <param name="target">The despawned object.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.Despawn(`0,System.Single,System.Boolean)">
            <summary>
            Despawns an object after a delay.
            </summary>
            <param name="target">The target to despawn.</param>
            <param name="delay">Time in seconds to wait before despawning the target.</param>
            <param name="unscaledTime">Should the delay be according to <see cref="P:UnityEngine.Time.time"/> or <see cref="P:UnityEngine.Time.unscaledTime"/>?</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.Pool`1.CancelDespawn(`0)">
            <summary>
            Cancels a pending timed despawn.
            </summary>
            <param name="target">The target that shouldn't despawn after all.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Pooling.PoolHelper">
            <summary>
            Simple static helper class for pooling Unity prefab instances.
            
            If the pooled objects implement <see cref="T:Archon.SwissArmyLib.Pooling.IPoolable"/> they will be notified when they're spawned and despawned.
            
            For non-Unity objects see <see cref="T:Archon.SwissArmyLib.Pooling.PoolHelper`1"/>.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.Spawn``1(``0)">
            <summary>
            Spawns a recycled object if there's one available, otherwise creates a new instance.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.Spawn``1(``0,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Transform)">
            <summary>
            Spawns a recycled object if there's one available, otherwise creates a new instance.
            </summary>
            <returns>The spawned object.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.Despawn(Archon.SwissArmyLib.Pooling.IPoolable)">
            <summary>
            Despawns an instance and marks it for reuse.
            </summary>
            <param name="target">The instance to despawn.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.GetPrefab(UnityEngine.Object)">
            <summary>
            Gets the prefab that was used to spawn <paramref name="instance"/>.
            </summary>
            <param name="instance">The instance to get the prefab for.</param>
            <returns>The prefab for the instance, or null if not found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.GetPrefab``1(``0)">
            <summary>
            Gets the prefab that was used to spawn <paramref name="instance"/>.
            </summary>
            <typeparam name="T">The type of the instance.</typeparam>
            <param name="instance">The instance to get the prefab for.</param>
            <returns>The prefab for the instance, or null if not found.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper.GetPool(UnityEngine.Object)">
            <summary>
            Gets or creates the pool for the given prefab.
            </summary>
            <param name="prefab">The prefab to get a pool for.</param>
            <returns>The pool for the prefab.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Pooling.PoolHelper`1">
            <summary>
            Simple static helper class for pooling non-Unity objects.
            
            If the pooled objects implement <see cref="T:Archon.SwissArmyLib.Pooling.IPoolable"/> they will be notified when they're spawned and despawned.
            
            For Unity GameObjects see <see cref="T:Archon.SwissArmyLib.Pooling.PoolHelper"/>.
            </summary>
            <typeparam name="T">The type of the object to pool.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper`1.Spawn">
            <summary>
            Spawns a recycled or new instance of the type <typeparamref name="T"/>.
            </summary>
            <returns>The spawned instance.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Pooling.PoolHelper`1.Despawn(`0)">
            <summary>
            Despawns an instance of the type <typeparamref name="T"/> and marks it for reuse.
            </summary>
            <param name="target">The instance to despawn.</param>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceEvent.OriginalDelta">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceEvent.ModifiedDelta">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceEvent.AppliedDelta">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceEvent.Source">
            <inheritdoc />
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceEvent.Args">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.IResourceChangeEvent">
            <summary>
            Defines an event for after a resource pool has been changed.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.IResourceChangeEvent.OriginalDelta">
            <summary>
            Gets the originally requested resource change.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.IResourceChangeEvent.ModifiedDelta">
            <summary>
            Gets the modified delta after listeners of <see cref="F:Archon.SwissArmyLib.ResourceSystem.ResourcePool.OnPreChange"/> had their chance to affect it.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.IResourceChangeEvent.AppliedDelta">
            <summary>
            Gets the actual applied (and clamped) delta. 
            Basically just the difference in resource amount before and after the change.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.IResourcePreChangeEvent">
            <summary>
            Defines a change event that has not yet happened, and can be altered.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.IResourcePreChangeEvent.OriginalDelta">
            <summary>
            Gets the originally requested resource change.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.IResourcePreChangeEvent.ModifiedDelta">
            <summary>
            Gets or sets the modified delta that will be applied after this event.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.IResourceEvent">
            <summary>
            Defines a barebones resource event.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.IResourceEvent.Source">
            <summary>
            Gets the source of the resource change. 
            Can be null.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.IResourceEvent.Args">
            <summary>
            Gets the args that the sender sent with the change.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool">
            <summary>
            A generic resource pool (eg. health, mana, energy).
            
            <seealso cref="T:Archon.SwissArmyLib.ResourceSystem.ResourceRegen"/>
            <seealso cref="T:Archon.SwissArmyLib.ResourceSystem.Shield"/>
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool.EventIds">
            <summary>
            Event ids for resource change events.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.ResourceSystem.ResourcePool.OnPreChange">
            <summary>
            Event called just before the resource amount is changed. 
            You can affect the applied change by modifying <see cref="P:Archon.SwissArmyLib.ResourceSystem.IResourcePreChangeEvent.ModifiedDelta"/>.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.ResourceSystem.ResourcePool.OnChange">
            <summary>
            Event called after the resource amount has been changed.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.ResourceSystem.ResourcePool.OnEmpty">
            <summary>
            Event called once the pool has been completely emptied.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.ResourceSystem.ResourcePool.OnFull">
            <summary>
            Event called when the pool has been completely filled.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.ResourceSystem.ResourcePool.OnRenew">
            <summary>
            Event called when the pool is renewed using <see cref="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool.Renew(System.Object,System.Object,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool.Current">
            <summary>
            Gets the current amount of resource in this pool.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool.Max">
            <summary>
            Gets or sets the maximum amount of source that can be in this pool.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool.EmptyTillRenewed">
            <summary>
            Gets or sets whether adding resource should be disabled after the pool is completely empty, until it is renewed using <see cref="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool.Renew(System.Object,System.Object,System.Boolean)"/> again.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool.Percentage">
            <summary>
            Gets a how full the resource is percentage-wise (0 to 1)
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool.IsEmpty">
            <summary>
            Gets whether the pool is completely empty.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool.IsFull">
            <summary>
            Gets whether the pool is completely empty.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool.Awake">
            <summary>
            Called when the MonoBehaviour is added to a GameObject.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool.Add(System.Single,System.Object,System.Object,System.Boolean)">
            <summary>
            Adds the specified amount of resource to the pool.
            </summary>
            <param name="amount">The amount to add.</param>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool.Remove(System.Single,System.Object,System.Object,System.Boolean)">
            <summary>
            Removes the specified amount of resource to the pool.
            </summary>
            <param name="amount">The amount to remove.</param>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool.Empty(System.Object,System.Object,System.Boolean)">
            <summary>
            Completely empties the pool.
            </summary>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool.Fill(System.Object,System.Object,System.Boolean)">
            <summary>
            Fully fills the pool.
            </summary>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool.Fill(System.Single,System.Object,System.Object,System.Boolean)">
            <summary>
            Fills the pool to the specified amount.
            </summary>
            <param name="toValue">The amount of resource to restore to.</param>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool.Renew(System.Object,System.Object,System.Boolean)">
            <summary>
            Fully restores the pool, regardless of <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool.EmptyTillRenewed"/>.
            </summary>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool.Renew(System.Single,System.Object,System.Object,System.Boolean)">
            <summary>
            Restores the pool to the specified amount, regardless of <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourcePool.EmptyTillRenewed"/>.
            </summary>
            <param name="toValue">The amount of resource to restore to.</param>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourcePool.Change(System.Single,System.Object,System.Object,System.Boolean)">
            <summary>
            Changes the resource amount by <paramref name="delta"/>.
            </summary>
            <param name="delta">The delta to apply.</param>
            <param name="source">The source of the change.</param>
            <param name="args">Optional args that will be passed to listeners.</param>
            <param name="forced">Controls whether to force the change, despite modifications by listeners.</param>
            <returns>The resulting change in the pool.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.ResourceRegen">
            <summary>
            Adds resource to a pool at a constant rate or in intervals.
            
            If the <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen.Target"/> is not set, it will try to find a resource pool on the same GameObject.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen.Interval">
            <summary>
            Gets or sets how often in seconds that <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen.AmountPerInterval"/> resources should be gained.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen.AmountPerInterval">
            <summary>
            Gets or sets the amount of resource that should be gained every <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen.Interval"/>.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen.ConstantAmountPerSecond">
            <summary>
            Gets or sets the amount of resource that should be gained per second.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen.DownTimeOnResourceLoss">
            <summary>
            Gets or sets the amount of time in seconds to stop healing after the <see cref="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen.Target"/> loses resource.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.ResourceRegen.Target">
            <summary>
            Gets or sets the target <see cref="T:Archon.SwissArmyLib.ResourceSystem.ResourcePool"/> that should regen.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourceRegen.Awake">
            <summary>
            Called when the MonoBehaviour is added to a GameObject.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourceRegen.OnEnable">
            <summary>
            Called when the MonoBehaviour is enabled.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourceRegen.OnDisable">
            <summary>
            Called when the MonoBehaviour is disabled.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.ResourceRegen.Update">
            <summary>
            Called every frame.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.ResourceSystem.Shield">
            <summary>
            A resource pool that is used to protect another resource pool from getting drained. 
            The shield intercepts the event and applies some of the change to itself, only letting part (or none at all) of the change get through.
            
            If the <see cref="P:Archon.SwissArmyLib.ResourceSystem.Shield.ProtectedTarget"/> is not set, it will try to find a resource pool on the same GameObject.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.Shield.ProtectedTarget">
            <summary>
            Gets or sets the target that this shield should protect.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.Shield.AbsorptionFlat">
            <summary>
            Gets or sets the flat amount of removed resource that should be absorbed by the shield.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.Shield.AbsorptionScaling">
            <summary>
            Gets or sets the fraction of removed resource that should be absorbed by the shield.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.Shield.EmptiesWithTarget">
            <summary>
            Gets or sets whether the shield should get fully drained when the target is empty.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.ResourceSystem.Shield.RenewsWithTarget">
            <summary>
            Gets or sets whether the shield should renew when the target does.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield.Awake">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield.OnEnable">
            <summary>
            Called when the MonoBehaviour is enabled.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield.OnDisable">
            <summary>
            Called when the MonoBehaviour is disabled.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield.Change(System.Single,System.Object,System.Object,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield.OnEvent(System.Int32,Archon.SwissArmyLib.ResourceSystem.IResourcePreChangeEvent)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield.OnEvent(System.Int32,Archon.SwissArmyLib.ResourceSystem.IResourceEvent)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.ResourceSystem.Shield.GetDefaultTarget">
            <summary>
            Attempts to find a different resource pool on this GameObject.
            </summary>
            <returns>The found pool, or null if none were found.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.BetterTime">
            <summary>
            A simple wrapper for Unity's <see cref="T:UnityEngine.Time"/> that caches values to avoid the marshal overhead of each call.
            
            The performance benefit is very small, but completely free.
            
            Only readonly <see cref="T:UnityEngine.Time"/> properties (except for <see cref="P:Archon.SwissArmyLib.Utils.BetterTime.FixedDeltaTime"/>) are cached, but everything is wrapped anyway so you don't have to use multiple time classes.
            
            Since this is just a wrapper just refer to Unity's documentation about what each property does.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.TimeScale">
            <summary>
            Gets or sets the scalar that is applied to <see cref="P:Archon.SwissArmyLib.Utils.BetterTime.Time"/>, <see cref="P:Archon.SwissArmyLib.Utils.BetterTime.DeltaTime"/> etc.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.FrameCount">
            <summary>
            Gets the total number of frames that have passed.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.Time">
            <summary>
            Gets the (scaled) time in seconds at the beginning of this frame.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.DeltaTime">
            <summary>
            Gets the difference in seconds since the last frame. (Scaled according to <see cref="P:Archon.SwissArmyLib.Utils.BetterTime.TimeScale"/>)
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.SmoothDeltaTime">
            <summary>
            Gets a smoothed out time difference in seconds since the last frame. (Scaled according to <see cref="P:Archon.SwissArmyLib.Utils.BetterTime.TimeScale"/>)
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.UnscaledDeltaTime">
            <summary>
            Gets the unscaled time difference in seconds since the last frame.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.UnscaledTime">
            <summary>
            Gets the unscaled time in seconds at the beginning of this frame.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.FixedDeltaTime">
            <summary>
            Gets or sets the fixed time in seconds between FixedUpdate.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.FixedTime">
            <summary>
            Gets the time that the latest FixedUpdate started. This is scaled according to <see cref="P:Archon.SwissArmyLib.Utils.BetterTime.TimeScale"/>.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.FixedUnscaledDeltaTime">
            <summary>
            Gets the unscaled time difference since the previous FixedUpdate.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.FixedUnscaledTime">
            <summary>
            Gets the unscaled time that the latest FixedUpdate started. 
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.InFixedTimeStep">
            <summary>
            Gets whether we're inside a FixedUpdate at the moment.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.RealTimeSinceStartup">
            <summary>
            Gets the real time in seconds since the game started.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.TimeSinceLevelLoad">
            <summary>
            Gets the time since the last level was loaded.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.MaximumDeltaTime">
            <summary>
            Gets or sets the maximum time in seconds that a fixed timestep frame can take. 
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.MaximumParticleDeltaTime">
            <summary>
            Gets or sets the maximum time in seconds that a frame can spend on updating particles.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.BetterTime.CaptureFramerate">
            <summary>
            Slows game playback time to allow screenshots to be saved between frames.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.Editor.ExecutionOrderAttribute">
            <summary>
            Changes the ScriptExecutionOrder of a <see cref="T:UnityEngine.MonoBehaviour"/> if it's not already explicitly set (or if <see cref="F:Archon.SwissArmyLib.Utils.Editor.ExecutionOrderAttribute.Forced"/> is true).
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Utils.Editor.ExecutionOrderAttribute.Order">
            <summary>
            The order you want for the script to have.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Utils.Editor.ExecutionOrderAttribute.Forced">
            <summary>
            Whether you want the order to be forcibly set and not just used as a default value.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.Editor.ReadOnlyAttribute">
            <summary>
            Marks the field to be unchangable via the inspector.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Utils.Editor.ReadOnlyAttribute.OnlyWhilePlaying">
            <summary>
            Whether it should only be readonly during play mode.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.Lazy`1">
            <summary>
            Provides support for lazy initialization.
            
            If you're on .NET 4.0 or higher you might want to use System.Lazy instead.
            </summary>
            <typeparam name="T">The type of the lazily initialized value.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Lazy`1.Value">
            <summary>
            Gets the lazily initialized value of this <see cref="T:Archon.SwissArmyLib.Utils.Lazy`1"/> instance.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Lazy`1.IsValueCreated">
            <summary>
            Gets whether the value has been initialized.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Lazy`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Archon.SwissArmyLib.Utils.Lazy`1"/> class. 
            The default constructor will be used to create the lazily initialized value.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Lazy`1.#ctor(System.Func{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Archon.SwissArmyLib.Utils.Lazy`1"/> class. 
            The specified initialization function will be used.
            </summary>
            <param name="valueFactory">The function to use for producing the lazily initialized value.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Lazy`1.ToString">
            <summary>
            Creates a string representation of <see cref="P:Archon.SwissArmyLib.Utils.Lazy`1.Value"/> property for this instance.
            </summary>
            <returns>The result of ToString() on the lazily initialized value.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Lazy`1.op_Explicit(Archon.SwissArmyLib.Utils.Lazy{`0})~`0">
            <summary>
            Explicitly casts the <paramref name="lazy"/> to its lazily initialized value.
            </summary>
            <param name="lazy"></param>
            <returns><see cref="P:Archon.SwissArmyLib.Utils.Lazy`1.Value"/></returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.ServiceLocator">
            <summary>
                A (somewhat) simple implementation of the service locator pattern.
                The ServiceLocator knows about MonoBehaviours and how to work with them.
                Creating scene-specific resolvers that only live as long as their respective scene is also supported.
                <remarks>
                    Please note that when you load a new scene, the MonoBehaviours in that scene will have their Awake()
                    method called before their scene becomes the active one. This means you can't rely on
                    SceneManager.GetActiveScene() to return the scene they're in, so you might want to use GameObject.scene
                    to specify which scene to register the resolver for.
                </remarks>
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingleton``1">
            <summary>
                Registers a concrete singleton of the given type.
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterLazySingleton``1">
            <summary>
                Registers a concrete singleton of the given type.
                The instance won't be created until the first time it is resolved.
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``1">
            <summary>
                Registers a scene-specific concrete singleton of the given type.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterLazySingletonForScene``1">
            <summary>
                Registers a scene-specific concrete singleton of the given type.
                The instance won't be created until the first time it is resolved.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``1(UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a scene-specific concrete singleton of the given type.
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterLazySingletonForScene``1(UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a scene-specific concrete singleton of the given type.
                The instance won't be created until the first time it is resolved.
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingleton``2">
            <summary>
                Registers a concrete singleton of the type <typeparamref name="TConcrete" /> for the abstract type
                <typeparamref name="TAbstract" />.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterLazySingleton``2">
            <summary>
                Registers a concrete singleton of the type <typeparamref name="TConcrete" /> for the abstract type
                <typeparamref name="TAbstract" />.
                The instance won't be created until the first time it is resolved.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``2">
            <summary>
                Registers a scene-specific concrete singleton of the type <typeparamref name="TConcrete" /> for the abstract type
                <typeparamref name="TAbstract" />.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterLazySingletonForScene``2">
            <summary>
                Registers a scene-specific concrete singleton of the type <typeparamref name="TConcrete" /> for the abstract type
                <typeparamref name="TAbstract" />.
                The instance won't be created until the first time it is resolved.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``2(UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a scene-specific concrete singleton of the type <typeparamref name="TConcrete" /> for the abstract type
                <typeparamref name="TAbstract" />.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterLazySingletonForScene``2(UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a scene-specific concrete singleton of the type <typeparamref name="TConcrete" /> for the abstract type
                <typeparamref name="TAbstract" />.
                The instance won't be created until the first time it is resolved.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete singleton implementation.</typeparam>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingleton``1(``0)">
            <summary>
                Registers a specific instance to be a singleton for its concrete type.
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
            <param name="instance">The instance to register as a singleton.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``1(``0)">
            <summary>
                Registers a specific instance to be a scene-specific singleton for its concrete type.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
            <param name="instance">The instance to register as a singleton.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``1(``0,UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a specific instance to be a scene-specific singleton for its concrete type.
            </summary>
            <typeparam name="T">The type of the singleton.</typeparam>
            <param name="instance">The instance to register as a singleton.</param>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransient``1">
            <summary>
                Registers a concrete transient type.
                A new instance of the given type will be returned each time it is resolved.
            </summary>
            <typeparam name="T">The concrete transient type to register.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``1">
            <summary>
                Registers scene-specific a concrete transient type.
                A new instance of the given type will be returned each time it is resolved.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="T">The concrete transient type to register.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``1(UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers scene-specific a concrete transient type.
                A new instance of the given type will be returned each time it is resolved.
            </summary>
            <typeparam name="T">The concrete transient type to register.</typeparam>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransient``2">
            <summary>
                Registers a concrete transient type to return new instances of when the abstract type
                <typeparamref name="TAbstract" /> is resolved.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete transient type to return when <typeparamref name="TAbstract" /> is resolved.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``2">
            <summary>
                Registers a scene-specific concrete transient type to return new instances of when the abstract type
                <typeparamref name="TAbstract" /> is resolved.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete transient type to return when <typeparamref name="TAbstract" /> is resolved.</typeparam>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``2(UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a scene-specific concrete transient type to return new instances of when the abstract type
                <typeparamref name="TAbstract" /> is resolved.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete transient type to return when <typeparamref name="TAbstract" /> is resolved.</typeparam>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransient``1(System.Func{``0})">
            <summary>
                Registers a concrete transient type to return new instances of when <typeparamref name="T" /> is resolved.
                The specified resolver will be used for producing the instances.
            </summary>
            <typeparam name="T">The concrete transient type to register.</typeparam>
            <param name="factory">The factory that will be used for creating instances.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``1(System.Func{``0})">
            <summary>
                Registers a scene-specific concrete transient type to return new instances of when <typeparamref name="T" /> is
                resolved.
                The specified resolver will be used for producing the instances.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="T">The concrete transient type to register.</typeparam>
            <param name="factory">The factory that will be used for creating instances.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``1(System.Func{``0},UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a scene-specific concrete transient type to return new instances of when <typeparamref name="T" /> is
                resolved.
                The specified resolver will be used for producing the instances.
            </summary>
            <typeparam name="T">The concrete transient type to register.</typeparam>
            <param name="factory">The factory that will be used for creating instances.</param>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransient``2(System.Func{``1})">
            <summary>
                Registers a concrete transient type to return new instances of when the abstract type
                <typeparamref name="TAbstract" /> is resolved.
                The specified resolver will be used for producing the instances.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete transient type to return when <typeparamref name="TAbstract" /> is resolved.</typeparam>
            <param name="factory">The factory that will be used for creating instances.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``2(System.Func{``1})">
            <summary>
                Registers a scene-specific concrete transient type to return new instances of when the abstract type
                <typeparamref name="TAbstract" /> is resolved.
                The specified resolver will be used for producing the instances.
                <remarks>The resolver is registered for the active scene according to <see cref="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene" />.</remarks>
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete transient type to return when <typeparamref name="TAbstract" /> is resolved.</typeparam>
            <param name="factory">The factory that will be used for creating instances.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``2(System.Func{``1},UnityEngine.SceneManagement.Scene)">
            <summary>
                Registers a scene-specific concrete transient type to return new instances of when the abstract type
                <typeparamref name="TAbstract" /> is resolved.
                The specified resolver will be used for producing the instances.
            </summary>
            <typeparam name="TAbstract">The abstract type that will be mapped to <typeparamref name="TConcrete" />.</typeparam>
            <typeparam name="TConcrete">The concrete transient type to return when <typeparamref name="TAbstract" /> is resolved.</typeparam>
            <param name="factory">The factory that will be used for creating instances.</param>
            <param name="scene">The scene to register the transient type for.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.Resolve``1(System.Boolean)">
            <summary>
                Locates and returns a transient object or singleton of the specified type.
                Searches for a global object first, if nothing is found and <paramref name="includeActiveScene" /> is true then it
                searches for a scene specific resolver.
                Make sure the type is registered first.
                <seealso cref="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingleton``1(``0)" />
                <seealso cref="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransient``1" />
                <seealso cref="M:Archon.SwissArmyLib.Utils.ServiceLocator.ResolveForScene``1" />
            </summary>
            <typeparam name="T">The type to locate an implementation for.</typeparam>
            <param name="includeActiveScene">Whether to search for a scene specific resolver if a global one isn't found.</param>
            <returns>
                The transient object or singleton that is mapped to the specified type.
                If nothing is registered for <typeparamref name="T" /> the default value for the type is returned.
            </returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.ResolveForScene``1">
            <summary>
                Locates and returns a transient object or singleton of the specified type for the currently active scene.
                Make sure the type is registered first.
                <seealso cref="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``1(``0)" />
                <seealso cref="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``1" />
            </summary>
            <typeparam name="T">The type to locate an implementation for.</typeparam>
            <returns>
                The transient object or singleton that is mapped to the specified type.
                If nothing is registered for <typeparamref name="T" /> the default value for the type is returned.
            </returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.ResolveForScene``1(UnityEngine.SceneManagement.Scene)">
            <summary>
                Locates and returns a transient object or singleton of the specified type for the given scene.
                Make sure the type is registered first.
                <seealso cref="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterSingletonForScene``1(``0)" />
                <seealso cref="M:Archon.SwissArmyLib.Utils.ServiceLocator.RegisterTransientForScene``1" />
            </summary>
            <typeparam name="T">The type to locate an implementation for.</typeparam>
            <returns>
                The transient object or singleton that is mapped to the specified type.
                If nothing is registered for <typeparamref name="T" /> the default value for the type is returned.
            </returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.IsRegistered``1(System.Boolean)">
            <summary>
            Checks whether there's registered a resolver for a specific type.
            </summary>
            <typeparam name="T">The type to check if registered.</typeparam>
            <param name="includeActiveScene">Whether to search for a scene specific resolver if a global one isn't found.</param>
            <returns>True if registered, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.IsRegisteredInScene``1">
            <summary>
            Checks whether there's registered a scene-specific resolver for a specific type in the currently active scene.
            </summary>
            <typeparam name="T">The type to check if registered.</typeparam>
            <returns>True if registered, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.IsRegisteredInScene``1(UnityEngine.SceneManagement.Scene)">
            <summary>
            Checks whether there's registered a scene-specific resolver for a specific type in the specified scene.
            </summary>
            <typeparam name="T">The type to check if registered.</typeparam>
            <returns>True if registered, false otherwise.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.Reset">
            <summary>
                Clears all resolvers.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.ResetGlobal">
            <summary>
                Clears global resolvers.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.ResetScene">
            <summary>
                Clears the currently active scene's resolvers.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.ResetScene(UnityEngine.SceneManagement.Scene)">
            <summary>
                Clears a specific scene's resolvers.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ServiceLocator.ResetScenes">
            <summary>
                Clears all scene specific resolvers for all scenes.
            </summary>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.ColorUtils">
            <summary>
            Utility methods for <see cref="T:UnityEngine.Color"/>.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ColorUtils.ToHex(UnityEngine.Color)">
            <summary>
            Converts the given color to its equivalent hex color in the form of #RRGGBBAA (eg. #000000FF for opaque black).
            </summary>
            <param name="color">The color to convert.</param>
            <returns>The hex representation of <paramref name="color"/>.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.ColorUtils.RichTextColor(System.String,UnityEngine.Color)">
            <summary>
            Wraps the supplied string in rich text color tags.
            </summary>
            <param name="text">The text to be colored.</param>
            <param name="color">The color to make the text.</param>
            <returns><paramref name="text"/> wrapped in color tags.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.Extensions.ListExtensions">
            <summary>
            Extensions for List
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Extensions.ListExtensions.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
            Shuffles the list using FisherYates shuffle algorithm.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">The list to shuffle.</param>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.Shake.BaseShake`1">
            <summary>
            Represents an object that can shake a value of the type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of value to be shaked.</typeparam>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.UnscaledTime">
            <summary>
            Gets or sets whether the shake should use <see cref="P:UnityEngine.Time.time"/> or <see cref="P:UnityEngine.Time.unscaledTime"/>.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.Duration">
            <summary>
            Gets how long the shake last.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.Frequency">
            <summary>
            Gets the frequency of the shake.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.Amplitude">
            <summary>
            Gets the amplitude of the shake.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.NormalizedTime">
            <summary>
            Gets the shake's current progress in the range 0 to 1.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.IsDone">
            <summary>
            Gets whether the shake is done.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.StartTime">
            <summary>
            Gets or sets the time that the shake started.
            </summary>
        </member>
        <member name="P:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.CurrentTime">
            <summary>
            Gets the current scaled or unscaled time.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.Start(System.Single,System.Int32,System.Single)">
            <summary>
            Starts (or restarts) the shake with new parameters.
            </summary>
            <param name="amplitude">Amplitude of the new shake.</param>
            <param name="frequency">Frequency of the new shake.</param>
            <param name="duration">Duration of the new shake.</param>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.GetAmplitude">
            <summary>
            Gets the amplitude at the current time.
            </summary>
            <returns>The current amplitude.</returns>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Shake.BaseShake`1.GetAmplitude(System.Single)">
            <summary>
            Gets the amplitude at a specific (normalized) time.
            </summary>
            <param name="t">The normalized time to get the amplitude for (0-1)</param>
            <returns>The amplitude at the specific time.</returns>
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.Shake.Shake">
            <summary>
            An object that can shake a float over time.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Shake.Shake.Start(System.Single,System.Int32,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Shake.Shake.GetAmplitude(System.Single)">
            <inheritdoc />
        </member>
        <member name="T:Archon.SwissArmyLib.Utils.Shake.Shake2D">
            <summary>
            An object that can shake a <see cref="T:UnityEngine.Vector2"/> over time.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Utils.Shake.Shake2D.Horizontal">
            <summary>
            The shake used for shaking the <see cref="F:UnityEngine.Vector2.x"/> value of the <see cref="T:UnityEngine.Vector2"/>.
            </summary>
        </member>
        <member name="F:Archon.SwissArmyLib.Utils.Shake.Shake2D.Vertical">
            <summary>
            The shake used for shaking the <see cref="F:UnityEngine.Vector2.y"/> value of the <see cref="T:UnityEngine.Vector2"/>.
            </summary>
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Shake.Shake2D.Start(System.Single,System.Int32,System.Single)">
            <inheritdoc />
        </member>
        <member name="M:Archon.SwissArmyLib.Utils.Shake.Shake2D.GetAmplitude(System.Single)">
            <inheritdoc />
        </member>
    </members>
</doc>
